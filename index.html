<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TRINETRA ‚Äî Live Orbital Visualization</title>

  <!-- NASA WorldWind (unchanged) -->
  <script src="https://files.worldwind.arc.nasa.gov/artifactory/web/0.11.0/worldwind.min.js"></script>

  <!-- satellite.js for TLE propagation -->
  <script src="https://cdn.jsdelivr.net/npm/satellite.js@4.0.0/dist/satellite.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    /* (copied/kept your UI CSS exactly as requested) */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #000; overflow: hidden; height: 100vh;
    }
    #globe { width: 100%; height: 100%; position: absolute; }
    .panel { position: absolute; background: rgba(10,15,30,0.9); color:#fff; padding:15px 20px; border-radius:12px; backdrop-filter: blur(20px); border:1px solid rgba(100,150,255,0.4); box-shadow:0 8px 32px rgba(0,0,0,0.5); z-index:10;}
    #controls { top:20px; right:20px; width:260px; }
    #legend { bottom:20px; left:20px; width:240px; }
    #info { top:50%; right:20px; transform:translateY(-50%); width:320px; max-height:70vh; overflow-y:auto; display:none; }
    #loading { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(10,15,30,0.95); padding:30px 50px; border-radius:15px; border:2px solid #4af; z-index:100; }
    .spinner { border:4px solid rgba(100,150,255,0.3); border-top:4px solid #4af; border-radius:50%; width:40px; height:40px; animation:spin 1s linear infinite; margin:0 auto 15px; }
    @keyframes spin { 0%{transform:rotate(0deg);}100%{transform:rotate(360deg);} }
    h3 { margin:0 0 15px; font-size:17px; color:#4af; border-bottom:2px solid rgba(100,150,255,0.4); padding-bottom:10px; font-weight:600; }
    .stat { display:flex; justify-content:space-between; margin:10px 0; font-size:14px; align-items:center; }
    .stat-label { color:#aaa; } .stat-value { color:#0f0; font-weight:bold; font-family:'Courier New', monospace; font-size:15px; }
    .legend-item { display:flex; align-items:center; margin:10px 0; font-size:14px; }
    .legend-color { width:18px; height:18px; border-radius:50%; margin-right:12px; box-shadow:0 0 12px currentColor; border:2px solid currentColor; }
    input[type="range"] { width:100%; margin:10px 0; accent-color:#4af; height:6px; }
    label { display:block; margin:12px 0 6px; font-size:13px; color:#aaa; font-weight:500; }
    .close { float:right; cursor:pointer; font-size:26px; color:#f44; line-height:1; margin-top:-8px; transition:color 0.2s; }
    .close:hover { color:#f88; }
    .info-title { font-size:18px; color:#4af; margin-bottom:15px; font-weight:600; }
    button { background:rgba(68,170,255,0.2); border:1px solid #4af; color:#4af; padding:8px 15px; border-radius:6px; cursor:pointer; font-size:13px; margin-top:10px; transition:all 0.2s; width:100%; }
    button:hover { background:rgba(68,170,255,0.4); }
    /* search/filter styles */
    #searchPanel { top:20px; left:20px; width:300px; }
    .search-box { width:100%; padding:10px 15px; background:rgba(20,25,45,0.8); border:1px solid rgba(100,150,255,0.4); border-radius:8px; color:white; font-size:14px; margin-bottom:15px; }
    .search-box:focus { outline:none; border-color:#4af; box-shadow:0 0 8px rgba(68,170,255,0.5); }
    .filter-group { margin:15px 0; } .filter-title { font-size:14px; color:#aaa; margin-bottom:8px; font-weight:500; }
    .filter-options { display:flex; flex-wrap:wrap; gap:8px; } .filter-option { background:rgba(20,25,45,0.8); border:1px solid rgba(100,150,255,0.3); border-radius:6px; padding:6px 12px; font-size:12px; cursor:pointer; transition:all 0.2s; } .filter-option:hover{ background:rgba(30,35,55,0.9); } .filter-option.active{ background:#4af; color:#000; border-color:#4af; } .filter-option.active:hover{ background:#6bf; }
    .search-results { max-height:200px; overflow-y:auto; margin-top:10px; border-top:1px solid rgba(100,150,255,0.3); padding-top:10px; }
    .search-result { padding:8px 10px; margin:5px 0; background:rgba(20,25,45,0.6); border-radius:6px; cursor:pointer; font-size:13px; transition:background 0.2s; }
    .search-result:hover { background:rgba(30,35,55,0.8); }
    .search-result.selected { background:rgba(68,170,255,0.3); border-left:3px solid #4af; }
  </style>
</head>
<body>

  <canvas id="globe"></canvas>

  <div id="loading">
    <div class="spinner"></div>
    <div style="color:#4af; text-align:center; font-size:14px;">Loading live TLE data & initializing...</div>
    <div id="loadingMsg" style="color:#9cf; text-align:center; margin-top:8px; font-size:12px;"></div>
  </div>

  <!-- Search / Filter / Controls / Legend / Info (kept) -->
  <div id="searchPanel" class="panel">
    <h3>üîç Search & Filter</h3>
    <input type="text" id="searchInput" class="search-box" placeholder="Search satellites...">

    <div class="filter-group">
      <div class="filter-title">Object Type:</div>
      <div class="filter-options">
        <div class="filter-option active" data-type="all">All</div>
        <div class="filter-option" data-type="satellite">Satellites</div>
        <div class="filter-option" data-type="rocket">Rockets</div>
        <div class="filter-option" data-type="debris">Debris</div>
      </div>
    </div>

    <div class="filter-group">
      <div class="filter-title">Orbit Type:</div>
      <div class="filter-options">
        <div class="filter-option active" data-orbit="all">All</div>
        <div class="filter-option" data-orbit="leo">LEO</div>
        <div class="filter-option" data-orbit="meo">MEO</div>
        <div class="filter-option" data-orbit="geo">GEO</div>
        <div class="filter-option" data-orbit="heo">HEO</div>
      </div>
    </div>

    <div class="search-results" id="searchResults"></div>
  </div>

  <div id="controls" class="panel">
    <h3>üõ∞Ô∏è TRINETRA</h3>
    <label>Orbit Speed: <span id="speedVal">1.0</span>x</label>
    <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1">
    <div class="stat"><span class="stat-label">FPS:</span><span class="stat-value" id="fps">--</span></div>
    <div class="stat"><span class="stat-label">Visible:</span><span class="stat-value" id="visibleCount">0</span></div>
    <div class="stat"><span class="stat-label">Camera View:</span><span class="stat-value" id="cameraMode">Free</span></div>
  </div>

  <div id="legend" class="panel">
    <h3>üìä Objects</h3>
    <div class="legend-item"><div class="legend-color" style="background:#0f0;color:#0f0;"></div><span>Satellites: <b id="satCount">0</b></span></div>
    <div class="legend-item"><div class="legend-color" style="background:#f60;color:#f60;"></div><span>Rockets: <b id="rocketCount">0</b></span></div>
    <div class="legend-item"><div class="legend-color" style="background:#f00;color:#f00;"></div><span>Debris: <b id="debrisCount">0</b></span></div>
    <div class="stat" style="margin-top:15px;padding-top:15px;border-top:1px solid rgba(100,150,255,0.3);"><span class="stat-label">TOTAL:</span><span class="stat-value" id="totalCount">0</span></div>
  </div>

  <div id="info" class="panel">
    <span class="close" onclick="closeInfo()">√ó</span>
    <div id="infoContent"></div>
    <button id="followButton" onclick="toggleFollowCamera()">Follow Satellite</button>
  </div>

  <script>
  /****************************************************************
   * Live TRINETRA index.html
   * - loads tles.json.br & sat_info.json.br (brotli)
   * - propagates in-browser with satellite.js (live positions)
   * - renders with NASA WorldWind (placemarks + trails + follow-view)
   ****************************************************************/

  // --------- Config / URLs ----------
  const GITHUB_BASE_RAW = 'https://raw.githubusercontent.com/harshbhanushali36/TRINETRA_PRODUCTION/main/data/latest';
  const TLES_URL = `${GITHUB_BASE_RAW}/tles.json.br`;
  const SATINFO_URL = `${GITHUB_BASE_RAW}/sat_info.json.br`;

  // animation/update intervals (ms)
  const PROPAGATION_UPDATE_MS = 1000; // recompute position every second
  const TRAIL_POINTS = 48;            // points when drawing orbit trails
  const TRAIL_DURATION_MINUTES = 90;  // generate trail for next N minutes (approx)

  // --------- Setup WorldWind ----------
  const wwd = new WorldWind.WorldWindow("globe");
  wwd.addLayer(new WorldWind.BMNGOneImageLayer());
  wwd.addLayer(new WorldWind.BMNGLandsatLayer());
  wwd.addLayer(new WorldWind.AtmosphereLayer());
  wwd.addLayer(new WorldWind.StarFieldLayer());
  wwd.addLayer(new WorldWind.CompassLayer());
  wwd.addLayer(new WorldWind.ViewControlsLayer(wwd));

  const objectLayer = new WorldWind.RenderableLayer("Objects");
  const trailLayer = new WorldWind.RenderableLayer("Trails");
  wwd.addLayer(objectLayer);
  wwd.addLayer(trailLayer);

  // --------- Globals ----------
  let sats = [];                 // internal list of satellites (objects with TLEs + placemark)
  let satInfoMap = {};           // metadata map by NORAD ID
  let selected = null;           // selected sat object
  let trailRenderable = null;    // current trail renderable
  let visibleSats = new Set();
  let activeFilters = { type: 'all', orbit: 'all' };
  let isFollowing = false;
  let followSatelliteId = null;

  // UI counters
  const counts = { satellite: 0, rocket: 0, debris: 0, other: 0 };

  // Orbit colors
  const ORBIT_COLORS = {
    'satellite': new WorldWind.Color(0, 1, 1, 0.9),
    'payload': new WorldWind.Color(0, 1, 1, 0.9),
    'rocket': new WorldWind.Color(1, 0.5, 0, 0.9),
    'rocket body': new WorldWind.Color(1, 0.5, 0, 0.9),
    'debris': new WorldWind.Color(1, 0, 0, 0.9),
    'unknown': new WorldWind.Color(0.8, 0.8, 0.8, 0.9)
  };

  // Helper: small icon canvas fallback
  function createIconDataUrl(type){
    const canvas = document.createElement('canvas'); canvas.width = canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const cmap = { satellite:'#00ff00', payload:'#00ff00', 'rocket body':'#ff6600', rocket:'#ff6600', debris:'#ff0000' };
    const color = (cmap[type.toLowerCase()] || '#ffff00');
    ctx.fillStyle = color;
    if(type.toLowerCase().includes('satellite') || type.toLowerCase().includes('payload')){
      ctx.beginPath(); ctx.moveTo(32,10); ctx.lineTo(54,32); ctx.lineTo(32,54); ctx.lineTo(10,32); ctx.closePath(); ctx.fill();
      ctx.fillStyle='#4444ff'; ctx.fillRect(15,25,34,4); ctx.fillRect(15,35,34,4);
    } else if(type.toLowerCase().includes('rocket')){
      ctx.beginPath(); ctx.moveTo(32,10); ctx.lineTo(50,54); ctx.lineTo(14,54); ctx.closePath(); ctx.fill();
    } else { ctx.beginPath(); ctx.arc(32,32,18,0,Math.PI*2); ctx.fill(); }
    return canvas.toDataURL();
  }

  // --------- Simple Brotli Decompression using dynamic import ----------
  async function decompressBrotli(compressedData) {
    try {
      // Try modern browser DecompressionStream first
      if (typeof DecompressionStream !== 'undefined') {
        const ds = new DecompressionStream('br');
        const stream = new Blob([compressedData]).stream().pipeThrough(ds);
        const decompressed = await new Response(stream).arrayBuffer();
        return new Uint8Array(decompressed);
      }
    } catch (e) {
      console.log('Native DecompressionStream not available, loading external decoder...');
    }
    
    // Fallback: Load brotli decoder dynamically
    if (typeof window.brotliDecoder === 'undefined') {
      try {
        // Load a simple, reliable brotli decoder
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/brotli@1.3.3/decompress.js';
        document.head.appendChild(script);
        
        // Wait for it to load
        await new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = () => reject(new Error('Failed to load brotli decoder'));
          setTimeout(() => reject(new Error('Brotli decoder load timeout')), 10000);
        });
        
        // Wait a bit more for the library to initialize
        await new Promise(resolve => setTimeout(resolve, 500));
      } catch (loadError) {
        throw new Error('Could not load Brotli decoder library. Please check your internet connection.');
      }
    }
    
    // Try using the loaded decoder
    if (typeof brotli !== 'undefined' && typeof brotli.decompress === 'function') {
      const inputArray = new Uint8Array(compressedData);
      return brotli.decompress(inputArray);
    }
    
    throw new Error('Brotli decompression not available. Your browser may not support this feature.');
  }

  // --------- Fetch and decompress brotli files ----------
  async function fetchData(url, progressText) {
    document.getElementById('loadingMsg').textContent = progressText || `Fetching ${url}`;
    
    try {
      const res = await fetch(url);
      if(!res.ok) throw new Error(`Failed to fetch ${url} (${res.status})`);
      
      const buf = await res.arrayBuffer();
      document.getElementById('loadingMsg').textContent = 'Decompressing data...';
      
      const decompressed = await decompressBrotli(buf);
      const text = new TextDecoder('utf-8').decode(decompressed);
      return JSON.parse(text);
    } catch(err) {
      console.error(`Error loading ${url}:`, err);
      throw err;
    }
  }

  // --------- Satellite propagation helpers ----------
  function propPositionFromTLE(tle1, tle2, date){
    const satrec = satellite.twoline2satrec(tle1, tle2);
    // propagate returns {position, velocity} in ECI (km)
    const p = satellite.propagate(satrec, date);
    if(!p || !p.position) return null;
    const gmst = satellite.gstime(date);
    const geo = satellite.eciToGeodetic(p.position, gmst);
    const lat = satellite.degreesLat(geo.latitude);
    const lon = satellite.degreesLong(geo.longitude);
    const altKm = geo.height; // km
    return { lat, lon, alt: altKm * 1000, rawPosECI: p.position };
  }

  // generate an approximate orbit trail (future positions) ‚Äî used on-demand
  function generateOrbitTrailPoints(tle1, tle2, minutes=TRAIL_DURATION_MINUTES, points=TRAIL_POINTS){
    const satrec = satellite.twoline2satrec(tle1, tle2);
    const now = new Date();
    const pts = [];
    for(let i=0;i<points;i++){
      const dt = new Date(now.getTime() + (i * (minutes*60000) / points));
      const p = satellite.propagate(satrec, dt);
      if(!p || !p.position) continue;
      const gmst = satellite.gstime(dt);
      const geo = satellite.eciToGeodetic(p.position, gmst);
      const lat = satellite.degreesLat(geo.latitude);
      const lon = satellite.degreesLong(geo.longitude);
      const altKm = geo.height;
      pts.push(new WorldWind.Position(lat, lon, altKm*1000));
    }
    return pts;
  }

  // add placemark for a satellite (and keep reference in sats array)
  function makePlacemarkForSat(s){
    const attrs = new WorldWind.PlacemarkAttributes(null);
    attrs.imageSource = createIconDataUrl(s.type || 'unknown');
    attrs.imageScale = 0.08;
    attrs.imageOffset = new WorldWind.Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.5);

    // initial placeholder position at (0,0,0) before propagation
    const pm = new WorldWind.Placemark(new WorldWind.Position(0,0,0), false, attrs);
    pm.userObject = s;
    pm.pickDelegate = s; // helps picking
    objectLayer.addRenderable(pm);

    return pm;
  }

  // show info panel for a satellite object
  function showSatelliteInfo(s){
    const meta = satInfoMap[String(s.id)] || {};
    const altitude = (s.position && s.position.alt) ? Math.round(s.position.alt/1000) : 'N/A';
    const orbitType = getOrbitType(altitude === 'N/A' ? 0 : altitude);
    const period = meta.period ? `${meta.period.toFixed(1)} min` : (s.orbit_period_minutes ? `${s.orbit_period_minutes} min` : 'N/A');

    document.getElementById('infoContent').innerHTML = `
      <div class="info-title">${meta.name || s.name || 'Unknown'}</div>
      <div class="stat"><span class="stat-label">Type:</span><span class="stat-value">${meta.object_type || s.type || 'N/A'}</span></div>
      <div class="stat"><span class="stat-label">ID:</span><span class="stat-value">${s.id || 'N/A'}</span></div>
      <div class="stat"><span class="stat-label">Altitude:</span><span class="stat-value">${altitude} km</span></div>
      <div class="stat"><span class="stat-label">Orbit:</span><span class="stat-value">${orbitType.toUpperCase()}</span></div>
      <div class="stat"><span class="stat-label">Period:</span><span class="stat-value">${period}</span></div>
      <div style="margin-top:10px; font-size:13px; color:#bde;">Launch: ${meta.launch_date || 'N/A'} | Country: ${meta.country || 'N/A'}</div>
    `;
    document.getElementById('info').style.display = 'block';
    document.getElementById('followButton').textContent = isFollowing && followSatelliteId===s.id ? 'Stop Following' : 'Follow Satellite';
  }

  function closeInfo(){
    document.getElementById('info').style.display = 'none';
    selected = null;
    isFollowing = false;
    followSatelliteId = null;
    document.getElementById('cameraMode').textContent = 'Free';
    if(trailRenderable){
      trailLayer.removeRenderable(trailRenderable);
      trailRenderable = null;
    }
  }

  function toggleFollowCamera(){
    if(!selected) return;
    isFollowing = !isFollowing;
    if(isFollowing){ followSatelliteId = selected.id; document.getElementById('cameraMode').textContent = 'Following'; }
    else { followSatelliteId = null; document.getElementById('cameraMode').textContent = 'Free'; }
  }

  function getOrbitType(alt){ if(alt < 2000) return 'leo'; if(alt < 35786) return 'meo'; if(alt >= 35786 && alt < 36000) return 'geo'; return 'heo'; }

  // ---------- Main loading + initialization ----------
  (async function main(){
    try{
      // Load TLE + info files (compressed or uncompressed based on USE_COMPRESSED flag)
      document.getElementById('loadingMsg').textContent = 'Fetching satellite data...';
      const [tlesArr, infoObj] = await Promise.all([
        fetchData(TLES_URL, 'Downloading TLE data...'),
        fetchData(SATINFO_URL, 'Downloading satellite info...')
      ]);

      // store metadata map
      satInfoMap = infoObj || {};

      // convert incoming tlesArr into internal sats list
      // expected tlesArr: [{ id: <number>, name: <string>, tle1: <str>, tle2: <str> }, ...]
      document.getElementById('loadingMsg').textContent = `Preparing ${tlesArr.length} TLEs...`;
      counts.satellite = counts.rocket = counts.debris = counts.other = 0;

      // create placemarks
      sats = tlesArr.map((entry, idx) => {
        const id = entry.id || (`_${idx}`);
        const name = entry.name || `object_${id}`;
        // pick a crude type using metadata map if available
        const meta = satInfoMap[String(id)] || {};
        const type = (meta.object_type || '').toString() || (entry.type || 'UNKNOWN');

        // create sat object
        const satObj = {
          id: id,
          name: name,
          tle1: String(entry.tle1 || entry.TLE_LINE1 || ''),
          tle2: String(entry.tle2 || entry.TLE_LINE2 || ''),
          type: String(type),
          orbit_period_minutes: meta.period || null,
          position: null, // {lat,lon,alt}
          placemark: null,
          lastPropagated: null,
          idx: Math.random() * 1000
        };

        // update counts
        const t = (satObj.type||'').toLowerCase();
        if(t.includes('satellite') || t.includes('payload')) counts.satellite++;
        else if(t.includes('rocket')) counts.rocket++;
        else if(t.includes('debris')) counts.debris++;
        else counts.other++;

        // create placemark & attach
        satObj.placemark = makePlacemarkForSat(satObj);
        return satObj;
      });

      // update UI counters
      document.getElementById('satCount').textContent = counts.satellite;
      document.getElementById('rocketCount').textContent = counts.rocket;
      document.getElementById('debrisCount').textContent = counts.debris;
      document.getElementById('totalCount').textContent = sats.length;
      sats.forEach(s=>visibleSats.add(s.id));
      document.getElementById('visibleCount').textContent = visibleSats.size;

      // hide loading
      document.getElementById('loading').style.display = 'none';

      // initial propagation and start loops
      await propagateAllOnce();
      startAnimationLoops();
    } catch(err){
      console.error(err);
      document.getElementById('loading').innerHTML = `
        <div style="color:#f44; text-align:center;">
          <h3>Error loading data</h3>
          <p style="margin:10px 0; font-size:13px;">${err.message}</p>
          <button onclick="location.reload()" style="margin-top:15px;">Retry</button>
        </div>
      `;
    }
  })();

  // ---------- Propagation + Animation ----------
  let lastFPS = Date.now(), frames = 0;
  let lastPropagate = 0;

  async function propagateAllOnce(){
    const now = new Date();
    for(const s of sats){
      const pos = propPositionFromTLE(s.tle1, s.tle2, now);
      if(pos){
        s.position = pos;
        s.lastPropagated = now;
        // update placemark position
        s.placemark.position = new WorldWind.Position(pos.lat, pos.lon, pos.alt);
      }
    }
    wwd.redraw();
  }

  function startAnimationLoops(){
    // propagation update timer
    setInterval(async ()=>{
      try {
        await propagateAllOnce();
      } catch(e){ console.warn('Propagation update error', e); }
    }, PROPAGATION_UPDATE_MS);

    // render animation loop (fps counter, follow camera updates)
    function frame(){
      requestAnimationFrame(frame);
      // FPS
      frames++;
      const now = Date.now();
      if(now - lastFPS > 1000){
        document.getElementById('fps').textContent = Math.round(frames * 1000 / (now - lastFPS));
        frames = 0; lastFPS = now;
      }

      // update placemark sizes/visibility based on filters
      filterSatellites();

      // follow camera if active
      if(isFollowing && followSatelliteId !== null){
        const s = sats.find(x=>String(x.id)===String(followSatelliteId));
        if(s && s.position){
          const pos = s.position;
          wwd.navigator.lookAtLocation.latitude = pos.lat;
          wwd.navigator.lookAtLocation.longitude = pos.lon;
          // range based on altitude: low alt => closer; high alt => farther
          const range = Math.max(100000, (pos.alt + 200000));
          wwd.navigator.range = range;
        }
      }

      wwd.redraw();
    }
    frame();
  }

  // ---------- UI: search / filter / click handling ----------
  document.getElementById('searchInput').addEventListener('input', function(e){
    const q = e.target.value.trim();
    searchSatellites(q);
  });

  function searchSatellites(q){
    const c = document.getElementById('searchResults');
    c.innerHTML = '';
    if(!q) return;
    const hits = sats.filter(s => (s.name || '').toLowerCase().includes(q.toLowerCase()) || String(s.id).includes(q));
    if(hits.length===0){ c.innerHTML = '<div style="color:#aaa;text-align:center;padding:10px;">No results</div>'; return; }
    hits.slice(0,10).forEach(s => {
      const d = document.createElement('div'); d.className='search-result';
      d.textContent = `${s.name} (${s.type||'N/A'})`;
      d.onclick = ()=>{ selectSatellite(s); c.innerHTML=''; document.getElementById('searchInput').value=''; };
      c.appendChild(d);
    });
  }

  // filter option handlers
  document.querySelectorAll('.filter-option[data-type]').forEach(opt=>{
    opt.addEventListener('click', e=>{
      document.querySelectorAll('.filter-option[data-type]').forEach(o=>o.classList.remove('active'));
      e.target.classList.add('active');
      activeFilters.type = e.target.dataset.type;
      filterSatellites();
    });
  });
  document.querySelectorAll('.filter-option[data-orbit]').forEach(opt=>{
    opt.addEventListener('click', e=>{
      document.querySelectorAll('.filter-option[data-orbit]').forEach(o=>o.classList.remove('active'));
      e.target.classList.add('active');
      activeFilters.orbit = e.target.dataset.orbit;
      filterSatellites();
    });
  });

  function filterSatellites(){
    visibleSats.clear();
    sats.forEach(s=>{
      const t = (s.type||'').toLowerCase();
      const alt = s.position ? s.position.alt/1000 : 0;
      const orbitType = getOrbitType(alt);
      const typeMatch = (activeFilters.type==='all') ||
        (activeFilters.type==='satellite' && (t.includes('satellite')||t.includes('payload'))) ||
        (activeFilters.type==='rocket' && t.includes('rocket')) ||
        (activeFilters.type==='debris' && t.includes('debris'));
      const orbitMatch = (activeFilters.orbit==='all') || (activeFilters.orbit===orbitType);
      if(typeMatch && orbitMatch){ s.placemark.enabled = true; visibleSats.add(s.id); } else { s.placemark.enabled=false; }
    });
    document.getElementById('visibleCount').textContent = visibleSats.size;
    wwd.redraw();
  }

  // clicking on globe to pick placemark
  wwd.addEventListener('click', (evt) => {
    const pickList = wwd.pick(wwd.canvasCoordinates(evt.clientX, evt.clientY));
    if(trailRenderable){ trailLayer.removeRenderable(trailRenderable); trailRenderable = null; }
    if(pickList.objects.length > 0){
      const picked = pickList.objects[0].userObject;
      // picked may be the sat userObject we stored
      const sat = sats.find(s => s.placemark === picked || s.name === (picked && picked.name));
      if(sat){ selectSatellite(sat); }
    } else {
      closeInfo();
    }
  });

  function selectSatellite(sat){
    closeInfo();
    selected = sat;
    // draw full trail (generateTrailPoints)
    const points = generateOrbitTrailPoints(sat.tle1, sat.tle2, TRAIL_DURATION_MINUTES, TRAIL_POINTS);
    if(points.length > 0){
      const path = new WorldWind.Path(points);
      path.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
      path.attributes = new WorldWind.ShapeAttributes(null);
      const color = (ORBIT_COLORS[(sat.type||'unknown').toLowerCase()] || ORBIT_COLORS.unknown);
      path.attributes.outlineColor = color;
      path.attributes.outlineWidth = 3;
      trailRenderable = path;
      trailLayer.addRenderable(path);
    }
    // ensure info & follow button
    if(sat.position){ showSatelliteInfo({ ...sat }); }
    // center camera a bit above current pos
    if(sat.position){
      wwd.navigator.lookAtLocation.latitude = sat.position.lat;
      wwd.navigator.lookAtLocation.longitude = sat.position.lon;
      wwd.navigator.range = Math.max(200000, sat.position.alt + 200000);
      wwd.redraw();
    }
  }

  // speed range UI
  document.getElementById('speed').oninput = e => { document.getElementById('speedVal').textContent = e.target.value; };

  // End of script
  </script>
</body>
</html>