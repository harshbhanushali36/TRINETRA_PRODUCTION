<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TRINETRA ‚Äî Live Orbital Visualization</title>

  <!-- Import Iceland font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Iceland&display=swap" rel="stylesheet">

  <!-- NASA WorldWind -->
  <script src="https://files.worldwind.arc.nasa.gov/artifactory/web/0.11.0/worldwind.min.js"></script>

  <!-- satellite.js for TLE propagation -->
  <script src="https://cdn.jsdelivr.net/npm/satellite.js@4.0.0/dist/satellite.min.js"></script>

  <!-- Pako for gzip decompression -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="styles.css">
 
</head>
<body>

  <!-- Background stars -->
  <div class="stars" id="stars"></div>

  <canvas id="globe"></canvas>

  <div id="loading">
    <div class="spinner"></div>
    <div class="loading-text">TRINETRA</div>
    <div class="loading-text">Loading live satellite data & initializing globe...</div>
    <div id="loadingMsg" style="color:#9cf; text-align:center; margin-top:8px; font-size:14px;"></div>
  </div>

  <!-- Search / Filter / Controls / Legend / Info -->
  <div id="searchPanel" class="panel">
    <h3>üîç Search & Filter</h3>
    <input type="text" id="searchInput" class="search-box" placeholder="Search satellites...">

    <div class="filter-group">
      <div class="filter-title">OBJECT TYPE:</div>
      <div class="filter-options">
        <div class="filter-option active" data-type="all">All</div>
        <div class="filter-option" data-type="satellite">Satellites</div>
        <div class="filter-option" data-type="rocket">Rockets</div>
        <div class="filter-option" data-type="debris">Debris</div>
      </div>
    </div>

    <div class="filter-group">
      <div class="filter-title">ORBIT TYPE:</div>
      <select id="orbitFilter" class="dropdown">
        <option value="all">All</option>
        <option value="leo">LEO</option>
        <option value="meo">MEO</option>
        <option value="geo">GEO</option>
        <option value="heo">HEO</option>
      </select>
    </div>

    <div class="search-results" id="searchResults"></div>
  </div>

  <div id="controls" class="panel">
    <h3>üõ∞Ô∏è TRINETRA</h3>
    <label>Orbit Speed: <span id="speedVal">1.0</span>x</label>
    <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1">
    <div class="stat"><span class="stat-label">FPS:</span><span class="stat-value" id="fps">--</span></div>
    <div class="stat"><span class="stat-label">Visible:</span><span class="stat-value" id="visibleCount">0</span></div>
    <div class="stat"><span class="stat-label">Camera View:</span><span class="stat-value" id="cameraMode">Free</span></div>
    <button id="followButton" onclick="toggleFollowCamera()">Follow Satellite</button>
  </div>

  <div id="legend" class="panel">
    <h3>üìä Objects</h3>
    <div class="legend-item">
      <img src="https://raw.githubusercontent.com/harshbhanushali36/TRINETRA_PRODUCTION/main/icons/satellite.png" class="legend-icon" alt="Satellite">
      <span>Satellites: <b id="satCount">0</b></span>
    </div>
    <div class="legend-item">
      <img src="https://raw.githubusercontent.com/harshbhanushali36/TRINETRA_PRODUCTION/main/icons/rocket.png" class="legend-icon" alt="Rocket">
      <span>Rockets: <b id="rocketCount">0</b></span>
    </div>
    <div class="legend-item">
      <img src="https://raw.githubusercontent.com/harshbhanushali36/TRINETRA_PRODUCTION/main/icons/debris.png" class="legend-icon" alt="Debris">
      <span>Debris: <b id="debrisCount">0</b></span>
    </div>
    <div class="stat" style="margin-top:15px;padding-top:15px;border-top:1px solid rgba(100,150,255,0.3);">
      <span class="stat-label">TOTAL:</span><span class="stat-value" id="totalCount">0</span>
    </div>
  </div>

  <div id="info" class="panel">
    <span class="close" onclick="closeInfo()">√ó</span>
    <div id="infoContent"></div>
  </div>

  <div id="geminiInfo" class="panel">
    <span class="close" onclick="closeGeminiInfo()">√ó</span>
    <h3>ü§ñ AI Satellite Assistant</h3>
    <div class="chat-container">
      <div class="chat-messages" id="geminiChatMessages">
        <div class="chat-message ai-message">
          Click on any satellite to get AI-powered information about its mission, launch details, and purpose. You can also ask questions!
        </div>
      </div>
      <div class="chat-input-container">
        <input type="text" class="chat-input" id="geminiChatInput" placeholder="Ask about this satellite...">
        <button class="send-button" onclick="sendChatMessage()">Send</button>
      </div>
    </div>
  </div>

  <script>
  /****************************************************************
   * TRINETRA - Enhanced Satellite Visualization
   * FIXED: Sped-up objects and object count issues
   ****************************************************************/

  // --------- Config / URLs ----------
  const GITHUB_BASE_RAW = 'https://raw.githubusercontent.com/harshbhanushali36/TRINETRA_PRODUCTION/main/data/latest';
  const TLES_URL = `${GITHUB_BASE_RAW}/tles.json.gz`;
  const SATINFO_URL = `${GITHUB_BASE_RAW}/sat_info.json.gz`;

  const PROPAGATION_UPDATE_MS = 5000;
  const TRAIL_POINTS = 48;
  const TRAIL_DURATION_MINUTES = 90;
  const BATCH_SIZE = 500;
  const BATCH_DELAY_MS = 50;

  // --------- Setup WorldWind ----------
  const wwd = new WorldWind.WorldWindow("globe");
  
  wwd.addLayer(new WorldWind.BMNGOneImageLayer());
  wwd.addLayer(new WorldWind.BMNGLandsatLayer());
  
  const atmosphereLayer = new WorldWind.AtmosphereLayer();
  atmosphereLayer.time = new Date();
  wwd.addLayer(atmosphereLayer);
  
  const starFieldLayer = new WorldWind.StarFieldLayer();
  starFieldLayer.altitude = 10000000;
  wwd.addLayer(starFieldLayer);
  
  wwd.addLayer(new WorldWind.CompassLayer());
  
  let viewControlsLayer = new WorldWind.ViewControlsLayer(wwd);
  wwd.addLayer(viewControlsLayer);

  const objectLayer = new WorldWind.RenderableLayer("Objects");
  const trailLayer = new WorldWind.RenderableLayer("Trails");
  wwd.addLayer(objectLayer);
  wwd.addLayer(trailLayer);

  wwd.navigator.lookAtLocation.latitude = 0;
  wwd.navigator.lookAtLocation.longitude = 0;
  wwd.navigator.range = 40000000;
  wwd.navigator.heading = 0;
  wwd.navigator.tilt = 0;

  // --------- Create background stars ----------
  function createStars() {
    const starsContainer = document.getElementById('stars');
    const starCount = 200;
    
    for (let i = 0; i < starCount; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      
      const left = Math.random() * 100;
      const top = Math.random() * 100;
      const size = Math.random() * 2 + 1;
      const delay = Math.random() * 5;
      
      star.style.left = `${left}%`;
      star.style.top = `${top}%`;
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
      star.style.animationDelay = `${delay}s`;
      
      starsContainer.appendChild(star);
    }
  }

  // --------- Globals ----------
  let sats = [];
  let satInfoMap = {};
  let selected = null;
  let trailRenderable = null;
  let visibleSats = new Set();
  let activeFilters = { type: 'all', orbit: 'all' };
  let isFollowing = false;
  let followSatelliteId = null;

  const counts = { satellite: 0, rocket: 0, debris: 0, other: 0 };

  const ORBIT_COLORS = {
    'satellite': new WorldWind.Color(0, 1, 1, 0.9),
    'payload': new WorldWind.Color(0, 1, 1, 0.9),
    'rocket': new WorldWind.Color(1, 0.5, 0, 0.9),
    'rocket body': new WorldWind.Color(1, 0.5, 0, 0.9),
    'debris': new WorldWind.Color(1, 0, 0, 0.9),
    'unknown': new WorldWind.Color(0.8, 0.8, 0.8, 0.9)
  };

  const GITHUB_ICONS_BASE = 'https://raw.githubusercontent.com/harshbhanushali36/TRINETRA_PRODUCTION/main/icons';
  const ICON_URLS = {
    'satellite': `${GITHUB_ICONS_BASE}/satellite.png`,
    'payload': `${GITHUB_ICONS_BASE}/satellite.png`,
    'rocket': `${GITHUB_ICONS_BASE}/rocket.png`,
    'rocket body': `${GITHUB_ICONS_BASE}/rocket.png`,
    'debris': `${GITHUB_ICONS_BASE}/debris.png`,
    'unknown': `${GITHUB_ICONS_BASE}/satellite.png`
  };

  function getIconUrl(type) {
    const lowerType = (type || 'unknown').toLowerCase();
    
    if (lowerType.includes('satellite') || lowerType.includes('payload')) {
      return ICON_URLS.satellite;
    } else if (lowerType.includes('rocket')) {
      return ICON_URLS.rocket;
    } else if (lowerType.includes('debris')) {
      return ICON_URLS.debris;
    }
    
    return ICON_URLS.unknown;
  }

  // --------- Gzip Decompression ----------
  async function decompressGzip(compressedData) {
    if (typeof pako === 'undefined') {
      throw new Error('Pako library not loaded. Please refresh the page.');
    }
    
    try {
      const inputArray = new Uint8Array(compressedData);
      const decompressed = pako.inflate(inputArray);
      return decompressed;
    } catch(err) {
      console.error('Gzip decompression error:', err);
      throw new Error('Failed to decompress gzip data: ' + err.message);
    }
  }

  async function fetchData(url, progressText) {
    document.getElementById('loadingMsg').textContent = progressText || `Fetching ${url}`;
    
    try {
      const res = await fetch(url);
      if(!res.ok) throw new Error(`Failed to fetch ${url} (${res.status})`);
      
      const buf = await res.arrayBuffer();
      document.getElementById('loadingMsg').textContent = 'Decompressing data...';
      
      const decompressed = await decompressGzip(buf);
      const text = new TextDecoder('utf-8').decode(decompressed);
      return JSON.parse(text);
    } catch(err) {
      console.error(`Error loading ${url}:`, err);
      throw err;
    }
  }

  // --------- Satellite propagation helpers ----------
  function propPositionFromTLE(tle1, tle2, date){
    const satrec = satellite.twoline2satrec(tle1, tle2);
    const p = satellite.propagate(satrec, date);
    if(!p || !p.position) return null;
    const gmst = satellite.gstime(date);
    const geo = satellite.eciToGeodetic(p.position, gmst);
    const lat = satellite.degreesLat(geo.latitude);
    const lon = satellite.degreesLong(geo.longitude);
    const altKm = geo.height;
    return { lat, lon, alt: altKm * 1000, rawPosECI: p.position };
  }

  function interpolatePosition(pos1, pos2, t) {
    if (!pos1 || !pos2) return pos1 || pos2;
    
    const smoothT = t * t * (3 - 2 * t);
    
    return {
      lat: pos1.lat + (pos2.lat - pos1.lat) * smoothT,
      lon: pos1.lon + (pos2.lon - pos1.lon) * smoothT,
      alt: pos1.alt + (pos2.alt - pos1.alt) * smoothT
    };
  }

  function generateOrbitTrailPoints(tle1, tle2, minutes=TRAIL_DURATION_MINUTES, points=TRAIL_POINTS){
    const satrec = satellite.twoline2satrec(tle1, tle2);
    const now = new Date();
    const pts = [];
    for(let i=0;i<points;i++){
      const dt = new Date(now.getTime() + (i * (minutes*60000) / points));
      const p = satellite.propagate(satrec, dt);
      if(!p || !p.position) continue;
      const gmst = satellite.gstime(dt);
      const geo = satellite.eciToGeodetic(p.position, gmst);
      const lat = satellite.degreesLat(geo.latitude);
      const lon = satellite.degreesLong(geo.longitude);
      const altKm = geo.height;
      pts.push(new WorldWind.Position(lat, lon, altKm*1000));
    }
    return pts;
  }

  function makePlacemarkForSat(s){
    const attrs = new WorldWind.PlacemarkAttributes(null);
    
    attrs.imageSource = getIconUrl(s.type);
    attrs.imageScale = 0.03;
    attrs.imageOffset = new WorldWind.Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.5);

    const pm = new WorldWind.Placemark(new WorldWind.Position(0,0,0), false, attrs);
    pm.userObject = s;
    pm.pickDelegate = s;
    objectLayer.addRenderable(pm);

    return pm;
  }

  function updatePNGSize() {
    const scale = isFollowing ? 0.05 : 0.03;
    
    sats.forEach(sat => {
      if (sat.placemark && sat.placemark.attributes) {
        sat.placemark.attributes.imageScale = scale;
      }
    });
    
    wwd.redraw();
  }

  // --------- AI Chat ----------
  let currentChatSatellite = null;
  let chatHistory = [];

  function addChatMessage(message, isUser = false) {
    const chatMessages = document.getElementById('geminiChatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${isUser ? 'user-message' : 'ai-message'}`;
    messageDiv.textContent = message;
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    chatHistory.push({
      role: isUser ? 'user' : 'assistant',
      message: message,
      timestamp: new Date()
    });
  }

  async function sendChatMessage() {
    const input = document.getElementById('geminiChatInput');
    const message = input.value.trim();
    
    if (!message || !currentChatSatellite) return;
    
    input.value = '';
    addChatMessage(message, true);
    
    const chatMessages = document.getElementById('geminiChatMessages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'ai-loading';
    loadingDiv.innerHTML = '<div class="spinner" style="width:20px;height:20px;margin:5px auto;"></div>';
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    try {
      const response = await askGroqDirectly(currentChatSatellite, message);
      
      if (chatMessages.contains(loadingDiv)) {
        chatMessages.removeChild(loadingDiv);
      }
      
      addChatMessage(response);
      
    } catch (error) {
      console.error("Error in sendChatMessage:", error);
      
      if (chatMessages.contains(loadingDiv)) {
        chatMessages.removeChild(loadingDiv);
      }
      
      try {
        const fallbackResponse = await simulateGeminiAPI(currentChatSatellite, message);
        addChatMessage(fallbackResponse);
      } catch (fallbackError) {
        addChatMessage(`I apologize, but I'm having trouble accessing satellite information right now. Please try again in a moment.`);
      }
    }
  }

  async function askGroqDirectly(satellite, userMessage) {
    const API_KEY = "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";

    try {
      const meta = satInfoMap[String(satellite.id)] || {};
      const altitude = satellite.position?.alt ? Math.round(satellite.position.alt / 1000) : 'Unknown';
      const orbitType = getOrbitType(altitude === 'Unknown' ? 0 : altitude).toUpperCase();

      const satContext = `
SATELLITE INFORMATION:
- Name: ${satellite.name}
- Type: ${meta.object_type || satellite.type || "Unknown"}
- NORAD ID: ${satellite.id}
- Orbit: ${orbitType}
- Altitude: ${altitude} km
- Launch Date: ${meta.launch_date || "Unknown"}
- Country: ${meta.country || "Unknown"}
- Period: ${meta.period ? `${meta.period.toFixed(1)} minutes` : "Unknown"}

USER QUESTION: ${userMessage}
`.trim();

      const requestBody = {
        model: "llama-3.1-8b-instant",
        messages: [
          { 
            role: "system", 
            content: "You are a satellite expert. Provide accurate, helpful information about satellites. Be concise but informative." 
          },
          { 
            role: "user", 
            content: satContext
          }
        ],
        temperature: 0.3,
        max_tokens: 1000
      };

      const response = await fetch("https://api.groq.com/openai/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${API_KEY}`
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error("Groq API error:", errorText);
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      
      let answer = "";
      
      if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        answer = data.choices[0].message.content.trim();
      } else if (data.choices && data.choices[0] && data.choices[0].text) {
        answer = data.choices[0].text.trim();
      } else {
        answer = `Based on the available data, ${satellite.name} is a ${meta.object_type || satellite.type || 'satellite'} in ${orbitType} orbit. For specific information about "${userMessage}", additional details would be needed from specialized satellite databases.`;
      }
      
      if (!answer || answer.length < 10) {
        throw new Error("Response too short or empty");
      }
      
      return answer;

    } catch (error) {
      console.error("Groq API call failed:", error);
      
      const meta = satInfoMap[String(satellite.id)] || {};
      const altitude = satellite.position?.alt ? Math.round(satellite.position.alt / 1000) : 'Unknown';
      const orbitType = getOrbitType(altitude === 'Unknown' ? 0 : altitude).toUpperCase();
      
      return `I'm currently unable to access detailed satellite information. However, here's what I know:\n\n${satellite.name} is a ${meta.object_type || satellite.type || 'satellite'} in ${orbitType} orbit at ${altitude} km altitude. For comprehensive details about "${userMessage}", please check space-track.org or celestrak.org.`;
    }
  }

  async function simulateGeminiAPI(satellite, userMessage) {
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const meta = satInfoMap[String(satellite.id)] || {};
    const altitude = (satellite.position && satellite.position.alt) ? Math.round(satellite.position.alt/1000) : 'Unknown';
    const orbitType = getOrbitType(altitude === 'Unknown' ? 0 : altitude).toUpperCase();
    
    const question = userMessage.toLowerCase();
    
    if (question.includes('mission') || question.includes('purpose')) {
      return `${satellite.name} appears to be a ${meta.object_type || satellite.type || 'satellite'} operating in ${orbitType} orbit. Based on its orbital characteristics, it's likely used for ${getMissionType(orbitType, satellite.type)}. The satellite was launched ${meta.launch_date ? 'around ' + meta.launch_date : 'at an unknown date'} and is operated by ${meta.country || 'an unknown entity'}.`;
    } 
    else if (question.includes('orbit') || question.includes('altitude')) {
      return `${satellite.name} is currently in a ${orbitType} orbit at approximately ${altitude} km altitude. ${orbitType === 'LEO' ? 'Low Earth Orbit satellites typically complete an orbit every 90-120 minutes and are used for Earth observation, communications, and scientific research.' : orbitType === 'GEO' ? 'Geostationary Orbit satellites remain fixed over one point on Earth and are commonly used for weather monitoring and communications.' : 'This orbit provides a balance between coverage area and signal latency.'}`;
    }
    else if (question.includes('launch') || question.includes('date')) {
      return `${satellite.name} was ${meta.launch_date ? 'launched around ' + meta.launch_date : 'launched at an unknown date'}. ${meta.country ? 'It is operated by ' + meta.country + '.' : ''}`;
    }
    else {
      return `${satellite.name} is a ${meta.object_type || satellite.type || 'satellite'} in ${orbitType} orbit. It orbits at ${altitude} km altitude and was ${meta.launch_date ? 'launched around ' + meta.launch_date : 'launched at an unknown date'}. ${meta.country ? 'It is operated by ' + meta.country + '.' : ''} This satellite is primarily used for ${getMissionType(orbitType, satellite.type)}.`;
    }
  }

  function getMissionType(orbitType, satelliteType) {
    const type = (satelliteType || '').toLowerCase();
    
    if (type.includes('debris')) return 'no active mission (space debris)';
    if (type.includes('rocket')) return 'launch vehicle component';
    
    switch(orbitType) {
      case 'LEO': return 'Earth observation, scientific research, or communications';
      case 'MEO': return 'navigation (like GPS) or communications';
      case 'GEO': return 'weather monitoring, communications, or broadcasting';
      case 'HEO': return 'specialized communications or scientific missions';
      default: return 'various space applications';
    }
  }

  function initializeChat(satellite) {
    currentChatSatellite = satellite;
    chatHistory = [];
    
    const chatMessages = document.getElementById('geminiChatMessages');
    chatMessages.innerHTML = '';
    
    addChatMessage(`Hello! I can provide information about ${satellite.name}. Ask me anything about its mission, technical specifications, or orbital characteristics.`);
  }

  function closeGeminiInfo() {
    document.getElementById('geminiInfo').style.display = 'none';
    currentChatSatellite = null;
    chatHistory = [];
  }

  document.addEventListener('DOMContentLoaded', function() {
    const chatInput = document.getElementById('geminiChatInput');
    if (chatInput) {
      chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          sendChatMessage();
        }
      });
    }
  });

  // --------- Info Panel ----------
  function showSatelliteInfo(s){
    const meta = satInfoMap[String(s.id)] || {};
    const altitude = (s.position && s.position.alt) ? Math.round(s.position.alt/1000) : 'N/A';
    const orbitType = getOrbitType(altitude === 'N/A' ? 0 : altitude);
    const period = meta.period ? `${meta.period.toFixed(1)} min` : (s.orbit_period_minutes ? `${s.orbit_period_minutes} min` : 'N/A');

    document.getElementById('infoContent').innerHTML = `
      <div class="info-title">${meta.name || s.name || 'Unknown'}</div>
      <div class="stat"><span class="stat-label">Type:</span><span class="stat-value">${meta.object_type || s.type || 'N/A'}</span></div>
      <div class="stat"><span class="stat-label">ID:</span><span class="stat-value">${s.id || 'N/A'}</span></div>
      <div class="stat"><span class="stat-label">Altitude:</span><span class="stat-value">${altitude} km</span></div>
      <div class="stat"><span class="stat-label">Orbit:</span><span class="stat-value">${orbitType.toUpperCase()}</span></div>
      <div class="stat"><span class="stat-label">Period:</span><span class="stat-value">${period}</span></div>
      <div style="margin-top:10px; font-size:15px; color:#bde;">Launch: ${meta.launch_date || 'N/A'} | Country: ${meta.country || 'N/A'}</div>
    `;
    
    const controlsPanel = document.getElementById('controls');
    const controlsRect = controlsPanel.getBoundingClientRect();
    const infoPanel = document.getElementById('info');
    infoPanel.style.top = (controlsRect.bottom + 20) + 'px';
    infoPanel.style.display = 'block';
    
    document.getElementById('followButton').textContent = isFollowing && followSatelliteId===s.id ? 'Stop Following' : 'Follow Satellite';
  }

  function closeInfo(){
    document.getElementById('info').style.display = 'none';
    selected = null;
    
    viewControlsLayer.enabled = true;
    isFollowing = false;
    followSatelliteId = null;
    document.getElementById('cameraMode').textContent = 'Free';
    if(trailRenderable){
      trailLayer.removeRenderable(trailRenderable);
      trailRenderable = null;
    }
    
    updatePNGSize();
    document.getElementById('followButton').textContent = 'Follow Satellite';
  }

  function toggleFollowCamera(){
    if(!selected) return;
    isFollowing = !isFollowing;
    
    viewControlsLayer.enabled = true;
    
    if(isFollowing){ 
      followSatelliteId = selected.id; 
      document.getElementById('cameraMode').textContent = 'Following'; 
    }
    else { 
      followSatelliteId = null; 
      document.getElementById('cameraMode').textContent = 'Free'; 
    }
    
    document.getElementById('followButton').textContent = isFollowing ? 'Stop Following' : 'Follow Satellite';
    updatePNGSize();
  }

  function getOrbitType(alt){ 
    if(alt < 2000) return 'leo'; 
    if(alt < 35786) return 'meo'; 
    if(alt >= 35786 && alt < 36000) return 'geo'; 
    return 'heo'; 
  }

  // FIXED: Improved validation to catch truly invalid TLEs while keeping valid satellites
  function isValidTLE(tle1, tle2) {
    if (!tle1 || !tle2) return false;
    
    const tle1Parts = tle1.trim().split(/\s+/);
    const tle2Parts = tle2.trim().split(/\s+/);
    
    if (tle1Parts.length < 8 || tle2Parts.length < 7) return false;
    
    try {
      const satrec = satellite.twoline2satrec(tle1, tle2);
      
      const inclination = satrec.inclo * (180 / Math.PI);
      if (isNaN(inclination) || inclination < 0 || inclination > 180) return false;
      
      if (isNaN(satrec.ecco) || satrec.ecco < 0 || satrec.ecco >= 0.99) return false;
      
      if (isNaN(satrec.no) || satrec.no < 0.01 || satrec.no > 20) return false;
      
      if (!isFinite(satrec.inclo) || !isFinite(satrec.ecco) || !isFinite(satrec.no)) return false;
      
      return true;
    } catch (e) {
      return false;
    }
  }

  // --------- Main Loading ----------
  (async function main(){
    try{
      createStars();
      
      document.getElementById('loadingMsg').textContent = 'Fetching satellite data...';
      const [tlesArr, infoObj] = await Promise.all([
        fetchData(TLES_URL, 'Downloading TLE data (gzip)...'),
        fetchData(SATINFO_URL, 'Downloading satellite info (gzip)...')
      ]);

      satInfoMap = infoObj || {};

      document.getElementById('loadingMsg').textContent = `Preparing ${tlesArr.length} TLEs...`;
      counts.satellite = counts.rocket = counts.debris = counts.other = 0;

      let filteredCount = 0;
      const validTLEs = tlesArr.filter(entry => {
        const isValid = isValidTLE(entry.tle1 || entry.TLE_LINE1, entry.tle2 || entry.TLE_LINE2);
        if (!isValid) {
          filteredCount++;
          if (filteredCount <= 10) {
            console.warn('Filtered invalid TLE:', entry.name || entry.id);
          }
        }
        return isValid;
      });

      document.getElementById('loadingMsg').textContent = `Filtered ${tlesArr.length - validTLEs.length} invalid TLEs, preparing ${validTLEs.length} satellites...`;

      sats = validTLEs.map((entry, idx) => {
        const id = entry.id || (`_${idx}`);
        const name = entry.name || `object_${id}`;
        const meta = satInfoMap[String(id)] || {};
        const type = (meta.object_type || '').toString() || (entry.type || 'UNKNOWN');

        const satObj = {
          id: id,
          name: name,
          tle1: String(entry.tle1 || entry.TLE_LINE1 || ''),
          tle2: String(entry.tle2 || entry.TLE_LINE2 || ''),
          type: String(type),
          orbit_period_minutes: meta.period || null,
          position: null,
          nextPosition: null,
          placemark: null,
          lastPropagated: null,
          satrec: null,
          idx: Math.random() * 1000,
          isValid: true
        };

        const t = (satObj.type||'').toLowerCase();
        if(t.includes('satellite') || t.includes('payload')) counts.satellite++;
        else if(t.includes('rocket')) counts.rocket++;
        else if(t.includes('debris')) counts.debris++;
        else counts.other++;

        satObj.placemark = makePlacemarkForSat(satObj);
        return satObj;
      });

      document.getElementById('satCount').textContent = counts.satellite;
      document.getElementById('rocketCount').textContent = counts.rocket;
      document.getElementById('debrisCount').textContent = counts.debris;
      document.getElementById('totalCount').textContent = sats.length;

      document.getElementById('loadingMsg').textContent = 'Loading satellites progressively...';
      await loadSatellitesInBatches();

      document.getElementById('loading').style.display = 'none';

      startAnimationLoops();
    } catch(err){
      console.error(err);
      document.getElementById('loading').innerHTML = `
        <div style="color:#f44; text-align:center;">
          <h3>Error loading data</h3>
          <p style="margin:10px 0; font-size:15px;">${err.message}</p>
          <button onclick="location.reload()" style="margin-top:15px;">Retry</button>
        </div>
      `;
    }
  })();

  // --------- Propagation & Animation ----------
  let lastFPS = Date.now(), frames = 0;
  let lastPropagateTime = 0;
  let animationStartTime = Date.now();
  let lastFrameTime = Date.now();

  async function loadSatellitesInBatches() {
    const totalBatches = Math.ceil(sats.length / BATCH_SIZE);
    
    for (let batchIdx = 0; batchIdx < totalBatches; batchIdx++) {
      const start = batchIdx * BATCH_SIZE;
      const end = Math.min(start + BATCH_SIZE, sats.length);
      const batch = sats.slice(start, end);
      
      const progress = Math.round((end / sats.length) * 100);
      document.getElementById('loadingMsg').textContent = 
        `Loading satellites: ${end}/${sats.length} (${progress}%)`;
      
      const now = new Date();
      const future = new Date(now.getTime() + PROPAGATION_UPDATE_MS);
      
      for (const s of batch) {
        if (!s.isValid) continue;
        
        if (!s.satrec) {
          try {
            s.satrec = satellite.twoline2satrec(s.tle1, s.tle2);
            
            const testProp = satellite.propagate(s.satrec, now);
            if (!testProp || !testProp.position || isNaN(testProp.position.x)) {
              console.warn(`Propagation test failed for ${s.name}, disabling`);
              s.isValid = false;
              s.placemark.enabled = false;
              continue;
            }
          } catch (e) {
            console.warn(`Invalid TLE for ${s.name}, disabling:`, e);
            s.isValid = false;
            s.placemark.enabled = false;
            continue;
          }
        }
        
        const pos = propPositionFromTLE(s.tle1, s.tle2, now);
        const nextPos = propPositionFromTLE(s.tle1, s.tle2, future);
        
        if (pos && nextPos && isFinite(pos.lat) && isFinite(pos.lon) && isFinite(pos.alt)) {
          s.position = pos;
          s.nextPosition = nextPos;
          s.lastPropagated = now;
          s.placemark.position = new WorldWind.Position(pos.lat, pos.lon, pos.alt);
          visibleSats.add(s.id);
        } else {
          s.isValid = false;
          s.placemark.enabled = false;
        }
      }
      
      document.getElementById('visibleCount').textContent = visibleSats.size;
      wwd.redraw();
      
      if (batchIdx < totalBatches - 1) {
        await new Promise(resolve => setTimeout(resolve, BATCH_DELAY_MS));
      }
    }
    
    lastPropagateTime = Date.now();
    animationStartTime = lastPropagateTime;
  }

  async function propagateAllOnce(){
    const now = new Date();
    const future = new Date(now.getTime() + PROPAGATION_UPDATE_MS);
    
    let invalidCount = 0;
    
    for(const s of sats){
      if (!s.isValid) continue;
      
      const pos = propPositionFromTLE(s.tle1, s.tle2, now);
      const nextPos = propPositionFromTLE(s.tle1, s.tle2, future);
      
      if(pos && nextPos && isFinite(pos.lat) && isFinite(pos.lon) && isFinite(pos.alt)){
        s.position = pos;
        s.nextPosition = nextPos;
        s.lastPropagated = now;
      } else {
        s.isValid = false;
        s.placemark.enabled = false;
        invalidCount++;
      }
    }
    
    if (invalidCount > 0) {
      console.log(`Disabled ${invalidCount} satellites due to propagation errors`);
    }
    
    lastPropagateTime = Date.now();
    animationStartTime = lastPropagateTime;
  }

  function startAnimationLoops(){
    setInterval(async ()=>{
      try {
        await propagateAllOnce();
      } catch(e){ console.warn('Propagation update error', e); }
    }, PROPAGATION_UPDATE_MS);

    function frame(){
      requestAnimationFrame(frame);
      
      const now = Date.now();
      lastFrameTime = now;
      
      frames++;
      if(now - lastFPS > 1000){
        document.getElementById('fps').textContent = Math.round(frames * 1000 / (now - lastFPS));
        frames = 0; 
        lastFPS = now;
      }

      const timeSinceLastProp = now - lastPropagateTime;
      const speedMultiplier = parseFloat(document.getElementById('speed').value) || 1.0;
      const interpolationFactor = Math.min(timeSinceLastProp / PROPAGATION_UPDATE_MS, 1);

      for (const s of sats) {
        if (s.isValid && s.position && s.nextPosition && s.placemark.enabled) {
          const smoothPos = interpolatePosition(s.position, s.nextPosition, interpolationFactor);
          s.placemark.position = new WorldWind.Position(smoothPos.lat, smoothPos.lon, smoothPos.alt);
        }
      }

      filterSatellites();

      if(isFollowing && followSatelliteId !== null){
        const s = sats.find(x=>String(x.id)===String(followSatelliteId));
        if(s && s.isValid && s.position && s.nextPosition){
          const smoothPos = interpolatePosition(s.position, s.nextPosition, interpolationFactor);
          
          wwd.navigator.lookAtLocation.latitude = smoothPos.lat;
          wwd.navigator.lookAtLocation.longitude = smoothPos.lon;
          
          if (s.placemark) {
            s.placemark.enabled = true;
            s.placemark.attributes.imageScale = 0.05;
          }
        }
      }

      wwd.redraw();
    }
    frame();
  }

  // --------- UI: Search & Filter ----------
  document.getElementById('searchInput').addEventListener('input', function(e){
    const q = e.target.value.trim();
    searchSatellites(q);
  });

  document.getElementById('orbitFilter').addEventListener('change', function(e){
    activeFilters.orbit = e.target.value;
    filterSatellites();
  });

  function searchSatellites(q){
    const c = document.getElementById('searchResults');
    c.innerHTML = '';
    if(!q) return;
    const hits = sats.filter(s => (s.name || '').toLowerCase().includes(q.toLowerCase()) || String(s.id).includes(q));
    if(hits.length===0){ c.innerHTML = '<div style="color:#aaa;text-align:center;padding:10px;">No results</div>'; return; }
    hits.slice(0,10).forEach(s => {
      const d = document.createElement('div'); d.className='search-result';
      d.textContent = `${s.name} (${s.type||'N/A'})`;
      d.onclick = ()=>{ selectSatellite(s); c.innerHTML=''; document.getElementById('searchInput').value=''; };
      c.appendChild(d);
    });
  }

  document.querySelectorAll('.filter-option[data-type]').forEach(opt=>{
    opt.addEventListener('click', e=>{
      document.querySelectorAll('.filter-option[data-type]').forEach(o=>o.classList.remove('active'));
      e.target.classList.add('active');
      activeFilters.type = e.target.dataset.type;
      filterSatellites();
    });
  });

  function filterSatellites(){
    visibleSats.clear();
    sats.forEach(s=>{
      const t = (s.type||'').toLowerCase();
      const alt = s.position ? s.position.alt/1000 : 0;
      const orbitType = getOrbitType(alt);
      const typeMatch = (activeFilters.type==='all') ||
        (activeFilters.type==='satellite' && (t.includes('satellite')||t.includes('payload'))) ||
        (activeFilters.type==='rocket' && t.includes('rocket')) ||
        (activeFilters.type==='debris' && t.includes('debris'));
      const orbitMatch = (activeFilters.orbit==='all') || (activeFilters.orbit===orbitType);
      if(typeMatch && orbitMatch && s.isValid){ 
        s.placemark.enabled = true; 
        visibleSats.add(s.id); 
      } else { 
        s.placemark.enabled=false; 
      }
    });
    document.getElementById('visibleCount').textContent = visibleSats.size;
    wwd.redraw();
  }

  wwd.addEventListener('click', (evt) => {
    const pickList = wwd.pick(wwd.canvasCoordinates(evt.clientX, evt.clientY));
    if(trailRenderable){ trailLayer.removeRenderable(trailRenderable); trailRenderable = null; }
    if(pickList.objects.length > 0){
      const picked = pickList.objects[0].userObject;
      const sat = sats.find(s => s.placemark === picked || s.name === (picked && picked.name));
      if(sat){ selectSatellite(sat); }
    } else {
      closeInfo();
      closeGeminiInfo();
    }
  });

  function selectSatellite(sat){
    closeInfo();
    selected = sat;
    const points = generateOrbitTrailPoints(sat.tle1, sat.tle2, TRAIL_DURATION_MINUTES, TRAIL_POINTS);
    if(points.length > 0){
      const path = new WorldWind.Path(points);
      path.altitudeMode = WorldWind.RELATIVE_TO_GROUND;
      path.attributes = new WorldWind.ShapeAttributes(null);
      const color = (ORBIT_COLORS[(sat.type||'unknown').toLowerCase()] || ORBIT_COLORS.unknown);
      path.attributes.outlineColor = color;
      path.attributes.outlineWidth = 3;
      trailRenderable = path;
      trailLayer.addRenderable(path);
    }
    if(sat.position){ showSatelliteInfo({ ...sat }); }
    if(sat.position){
      wwd.navigator.lookAtLocation.latitude = sat.position.lat;
      wwd.navigator.lookAtLocation.longitude = sat.position.lon;
      wwd.navigator.range = Math.max(500000, sat.position.alt + 500000);
      wwd.redraw();
    }
    
    document.getElementById('geminiInfo').style.display = 'block';
    initializeChat(sat);
  }

  document.getElementById('speed').oninput = e => { document.getElementById('speedVal').textContent = e.target.value; };

  </script>
</body>
</html>
